var tipuesearch = {"pages":[{"title":"About","text":"CMSimfly 內容管理網誌 課程倉儲: https://github.com/chiamingyen/cmsimfly 內容管理: https://chiamingyen.github.io/cmsimfly/ 課程投影片: https://chiamingyen.github.io/cmsimfly/reveal 課程網誌: https://chiamingyen.github.io/cmsimfly/blog","tags":"misc","url":"./pages/about/"},{"title":"2020 Fall CP Pelican Blog 內容與 Google Blogger 同步","text":"Pelican Blog 內容與 Google Blogger 同步 from markdown import markdown from oauth2client import client from googleapiclient import sample_tools import os os.environ['TZ'] = 'Asia/Taipei' argv = \"\" # 認證並建立服務 # name of the api is \"blogger\", version is \"v3\" # description of the api is __doc__ # file name of the application: location of client_secrets.json service, flags = sample_tools.init( argv, 'blogger', 'v3', __doc__, \"./../../client_secrets.json\", scope='https://www.googleapis.com/auth/blogger') def get_cat_tag_content(data): # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 --- # 用跳行符號分割 data_list = data.split(\"\\n\") #第 2 行為 title title= data_list[1] #第 4 行為 category category = data_list[3] #第 5 行為 tags tags = data_list[4] # 有多項資料的 content 型別為數列 # 再將第 9 行之後的資料數列串回成以跳行隔開的資料 content = \"\\n\".join(data_list[8:]) # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 content = content.replace(' ', ' ') # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式 #content = content.replace('~~~python', '[code lang=\"python\"]') #content = content.replace('~~~', '[/code]') return title, category, tags, content # 從目前所在節點的 body pan 中取出類別, tags 以及文章內容 # p.h 為 @clean filename.md # 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案 md_filename = p.h.split(\" \")[1] with open(md_filename, 'r', encoding=\"utf-8\") as content_file: md_content = content_file.read() # title_str, category_str, tags_str, content = get_cat_tag_content(p.b) title_str, category_str, tags_str, content = get_cat_tag_content(md_content) category = category_str.split(\":\")[1] tags = tags_str.split(\":\")[1].split(\",\") tags.append(category) # title 是一個單獨的字串 title = title_str.split(\":\")[1] # 將 markdown 格式 content 轉為 html content = markdown(content) # 以下處理 content 的 標題 content = content.replace(\" \", \" \") content = content.replace(\" \", \" \") # g.es(content) try: ''' users = service.users() # 取得使用者 profile 資料 user = users.get(userId='self').execute() print('網誌名稱: %s' % user['displayName']) ''' blogs = service.blogs() # 取得使用者所建立網誌名稱 blogs = blogs.listByUser(userId='self').execute() # post_id is now blogs[\"items\"][0][\"id\"] blog_id = blogs[\"items\"][0][\"id\"] #for blog in blogs['items']: #print(blog['name'], blog['url']) posts = service.posts() # 新增網誌 post 時, 需要 post_id body = { \"kind\": \"blogger#post\", \"id\": blog_id, \"title\": title, # 利用 markdown 函式, 將 .md 的內文轉為 html, 作為 Blogger 的文章內容 \"content\": content, \"labels\": tags } insert = posts.insert(blogId=blog_id, body=body) posts_doc = insert.execute() post_id = posts_doc[\"id\"] #print(posts_doc) os.remove(\"blogger.dat\") # 利用最後的 child 節點來儲存 post_id to_save_post_id = p.insertAsLastChild() # 改為內文為空的節點, id 直接標在 head 標題 to_save_post_id.b = \"\" to_save_post_id.h = post_id # 因為新增節點, commander 必須 redraw c.redraw() g.es(\"post_id 為\", post_id) g.es(\"已經將資料送往 Blogger!\") except(client.AccessTokenRefreshError): g.es(\"error\") from markdown import markdown from oauth2client import client from googleapiclient import sample_tools import os os.environ['TZ'] = 'Asia/Taipei' argv = \"\" # 認證並建立服務 # name of the api is \"blogger\", version is \"v3\" # description of the api is __doc__ # file name of the application: location of client_secrets.json service, flags = sample_tools.init( argv, 'blogger', 'v3', __doc__, \"./../../client_secrets.json\", scope='https://www.googleapis.com/auth/blogger') def get_cat_tag_content(data): # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 --- # 用跳行符號分割 data_list = data.split(\"\\n\") #第 2 行為 title title= data_list[1] #第 4 行為 category category = data_list[3] #第 5 行為 tags tags = data_list[4] # 有多項資料的 content 型別為數列 # 再將第 9 行之後的資料數列串回成以跳行隔開的資料 content = \"\\n\".join(data_list[8:]) # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 content = content.replace(' ', ' ') # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式 #content = content.replace('~~~python', '[code lang=\"python\"]') #content = content.replace('~~~', '[/code]') return title, category, tags, content # 從目前所在節點的 body pan 中取出類別, tags 以及文章內容 # p.h 為 @clean filename.md # 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案 md_filename = p.h.split(\" \")[1] with open(md_filename, 'r', encoding=\"utf-8\") as content_file: md_content = content_file.read() # title_str, category_str, tags_str, content = get_cat_tag_content(p.b) title_str, category_str, tags_str, content = get_cat_tag_content(md_content) category = category_str.split(\":\")[1] tags = tags_str.split(\":\")[1].split(\",\") tags.append(category) # title 是一個單獨的字串 title = title_str.split(\":\")[1] # 將 markdown 格式 content 轉為 html content = markdown(content) # 以下處理 content 的 標題 content = content.replace(\" \", \" \") content = content.replace(\" \", \" \") # g.es(content) try: ''' users = service.users() # 取得使用者 profile 資料 user = users.get(userId='self').execute() print('網誌名稱: %s' % user['displayName']) ''' blogs = service.blogs() # 取得使用者所建立網誌名稱 blogs = blogs.listByUser(userId='self').execute() # post_id is now blogs[\"items\"][0][\"id\"] blog_id = blogs[\"items\"][0][\"id\"] #for blog in blogs['items']: #print(blog['name'], blog['url']) posts = service.posts() # 新增網誌 post 時, 需要 post_id body = { \"kind\": \"blogger#post\", \"id\": blog_id, \"title\": title, # 利用 markdown 函式, 將 .md 的內文轉為 html, 作為 Blogger 的文章內容 \"content\": content, \"labels\": tags } insert = posts.insert(blogId=blog_id, body=body) posts_doc = insert.execute() post_id = posts_doc[\"id\"] #print(posts_doc) os.remove(\"blogger.dat\") # 利用最後的 child 節點來儲存 post_id to_save_post_id = p.insertAsLastChild() # 改為內文為空的節點, id 直接標在 head 標題 to_save_post_id.b = \"\" to_save_post_id.h = post_id # 因為新增節點, commander 必須 redraw c.redraw() g.es(\"post_id 為\", post_id) g.es(\"已經將資料送往 Blogger!\") except(client.AccessTokenRefreshError): g.es(\"error\") edit_to_blogger 按鈕內容: from markdown import markdown from oauth2client import client from googleapiclient import sample_tools import os os.environ['TZ'] = 'Asia/Taipei' argv = \"\" # 認證並建立服務 # name of the api is \"blogger\", version is \"v3\" # description of the api is __doc__ # file name of the application: location of client_secrets.json service, flags = sample_tools.init( argv, 'blogger', 'v3', __doc__, \"./../../client_secrets.json\", scope='https://www.googleapis.com/auth/blogger') def get_cat_tag_content(data): # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 --- # 用跳行符號分割 data_list = data.split(\"\\n\") #第 2 行為 title title= data_list[1] #第 4 行為 category category = data_list[3] #第 5 行為 tags tags = data_list[4] # 有多項資料的 content 型別為數列 # 再將第 9 行之後的資料數列串回成以跳行隔開的資料 content = \"\\n\".join(data_list[8:]) # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 content = content.replace(' ', ' ') # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式 #content = content.replace('~~~python', '[code lang=\"python\"]') #content = content.replace('~~~', '[/code]') return title, category, tags, content # 從目前所在節點的 body pan 中取出類別, tags 以及文章內容 # p.h 為 @clean filename.md # 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案 md_filename = p.h.split(\" \")[1] with open(md_filename, 'r', encoding=\"utf-8\") as content_file: md_content = content_file.read() # title_str, category_str, tags_str, content = get_cat_tag_content(p.b) title_str, category_str, tags_str, content = get_cat_tag_content(md_content) category = category_str.split(\":\")[1] tags = tags_str.split(\":\")[1].split(\",\") tags.append(category) # title 是一個單獨的字串 title = title_str.split(\":\")[1] # 將 markdown 格式 content 轉為 html content = markdown(content) # 以下處理 content 的 標題 content = content.replace(\" \", \" \") content = content.replace(\" \", \" \") # g.es(content) try: blogs = service.blogs() # 取得使用者所建立網誌名稱 blogs = blogs.listByUser(userId='self').execute() blog_id = blogs[\"items\"][0][\"id\"] # 設法取得原 post 的 id postid_outline = p.getLastChild() # 直接從標題取得 post 的 id 號碼 post_id = postid_outline.h posts = service.posts() # 更新網誌文章時的 body body = { \"kind\": \"blogger#post\", \"title\": title, \"content\": content } # need to save postId to outline head update = posts.update(blogId=blog_id, postId=post_id, body=body, publish=True) update_doc = update.execute() os.remove(\"blogger.dat\") g.es(\"post_id 為\", post_id) g.es(\"已經將更新資料送往 Blogger!\") except(client.AccessTokenRefreshError): g.es(\"error\")","tags":"Misc","url":"./2020-Fall-整合同步-bit-Windows.html"},{"title":"2020 Fall CP 課程可攜式環境","text":"可攜程式環境 為了讓工程師可以在不同的 Windows 10 64 位元電腦上管理 CMSiMDE 網際內容管理系統, 因此需要 Python 解譯環境以及一個文字檔案的編輯器. 這裡所安裝的 Python 解譯器選擇由 C 所編寫的 CPython, 可以從 https://www.python.org/ 下載安裝. 但是在此我們要將 Python 解譯系統配置在 USB 隨身碟上, 使用者可以隨身攜帶, 一旦配置完成後, 可以在任何一台 Windows 10 64 位元的筆電或電腦上執行 Python 或 C 程式. 可攜 Python 程式環境的建立步驟: 安裝 Python 套件時, 不要安裝 pip, 之後將 Python38 目錄複製到 data 目錄中, 然後建立 start.bat 指定使用可攜系統中的 Python, 之後再利用 get-pip.py, 以命令列中的 python get-pip.py 安裝 pip. 可攜 Tiny C 程式環境的建立步驟: 從 https://bellard.org/tcc/ 下載 Tiny C, 將 tcc 解開壓縮後放到 data 目錄中. 然後修改 wscite 目錄中的 cpp.properties, 使用 Tiny C 類解譯 .c 程式. 選用的文字編輯器: https://www.scintilla.org/SciTE.html 建立完成的可攜程式環境: 下載 wcm2020_w2.7z (舊資料) 請重新下載 wcmj2020_tool.7z, 檔案大小為 435 MB, 解開壓縮後為 1.8 GB (其中包括 Mypaint, Dia 與 OBS 等) 將 wcmj2020_tool.7z 解壓縮到隨身碟或電腦硬碟中, 將 home 與 home_ipv6 目錄中的 .gitconfig user.name 與 user.email 改為自己的 Github 帳號與 email 後, 利用 start.bat 啟動可攜系統, 利用 stop.bat 關閉可攜系統.","tags":"Misc","url":"./2020-Fall-可攜程式-bit-Windows.html"},{"title":"2020 Fall CP 課程W9","text":"W9 免費軟體 Freeware 共享軟體 Shareware 綠色軟體 Greenware 電腦軟體與硬體簡介 Type of Computer： super computer 超級電腦 MainFrane 伺服器主機 Server 伺服器 PC 個人電腦 Microcontroler 微電腦 Mobile Phone 手機 硬體名稱 說明 比喻 CPU 中央處理器，電腦的心臟，速度越快效率越好。新一代的電腦甚至可以有多核心兩個以上的CPU。 如果將主機比喻為一家商店，那CPU可以說是店員，動作越快、反應越靈巧的店員可以增加銷售的速度。 記憶體RAM 電腦系統運作時暫時儲存資料的地方，其大小也是影響電腦速率快慢的重要因素，建議入門最起碼可以使用2G。因為記憶體大小很重要、而且價格不貴、又不容易損壞，因此「寧可過剩、不要不足」。 猶如商店的賣場面積，賣場越大可以擺的東西越多，客人需要即可直接銷售，而不必進入貨倉中翻箱倒櫃，浪費時間、拖垮效率。 硬碟 儲存系統軟體、應用軟體以及資料的儲存空間，目前一般大小約為數百G，一台主機可以裝多顆硬碟。 猶如貨倉的大小，貨倉越大當然可以囤積的商品越多。 光碟機、 燒錄機 光碟機：只能讀取CD、DVD含音樂、影片及資料，古董機。 燒錄機：本身已經具備讀取功能，並且能夠將各類檔案燒錄於光碟片上，並製作為音樂CD、影片DVD、或純粹備份資料片等，為目前的主流規格。 讀卡機 擁有不同的插槽、能夠讀取多種格式的記憶卡。 綠色軟體 Greenware 指一種免費、免安裝軟體，一般在網路上以無條件的方式發放的小型軟體。優點是檔案比較細小﹑不用安裝﹑刪除方便和只佔用少量系統資源，所以甚至可以放在 MP3 播放器或隨身碟中讀取。大部份綠色軟體更是開放源碼並不設權限、歡迎任何人士參與修改或增加功能。不過也有人將有版權的軟體透過一些技術，將它改成免安裝軟體，也稱為綠色軟體，此類軟體移除後直接刪除也不會將任何紀錄登錄檔訊息等留在本機電腦上。 共享軟體 Shareware 免費共用軟體，通常有「限期」或「功能限制」或是有條件免費使用 如：附加廣告。有些軟體的「試用版」也以共享軟體的形式於網路間分享以及提供下載。 免費軟體 Freeware 泛指一切不用金錢買回來的電腦軟體。開發者一般是因興趣或以分享性質而發放。亦有部份是因為不滿或希望改善現存軟體而自行開發另一個或替其最佳化程式。","tags":"Misc","url":"./2020-Fall-w9-bit-Windows.html"},{"title":"2020 Fall CP 課程W13","text":"W13 Pelican Blog 內容與 Google Blogger 同步 利用 Windows 10 設定 -> 選擇預設網頁瀏覽器, 使用 Google Chrome 作為預設瀏覽器. 隨身程式系統必須安裝 google-api-python-client 與 oauth2client pip install google-api-python-client oauth2client OAuth 2.0 client IDs 程式類別可以選擇 other 使用者完成 client_secrets.json 設定後, 必須將檔案存在倉儲目錄外部 Pelican Blog 內容與 Google Blogger 同步 利用 Windows 10 設定 -> 選擇預設網頁瀏覽器, 使用 Google Chrome 作為預設瀏覽器. 隨身程式系統必須安裝 google-api-python-client 與 oauth2client pip install google-api-python-client oauth2client OAuth 2.0 client IDs 程式類別可以選擇 other 使用者完成 client_secrets.json 設定後, 必須將檔案存在倉儲目錄外部","tags":"Misc","url":"./2020-Fall-w13-bit-Windows.html"},{"title":"2020 Fall CP 課程","text":"2018 Fall 一開始, 在一台已經 10 年的 32 位元的 Windows 7 操作系統中工作. 可攜的 Python 3.7.0 仍然可以配置, Leo Editor、PyQt5、flask、Markdown、pelican 與 bs4 的安裝, 也都沒有問題. 只有 Eric6 因為缺少必要模組與 Python 3.7.0 對應的 pyqt5-tools, 因此沒有安裝. 2018 Fall 一開始, 在一台已經 10 年的 32 位元的 Windows 7 操作系統中工作. 可攜的 Python 3.7.0 仍然可以配置, Leo Editor、PyQt5、flask、Markdown、pelican 與 bs4 的安裝, 也都沒有問題. 只有 Eric6 因為缺少必要模組與 Python 3.7.0 對應的 pyqt5-tools, 因此沒有安裝.","tags":"Misc","url":"./2020-Fall-32-bit-Windows.html"},{"title":"2020 Fall CP 課程","text":"MacBook 操作指南 參考資料: Mac OS X for Absolute Beginners.pdf (for @gm users only) Learn C on the Mac.pdf (for @gm users only) 這裡以 MacBook Air 2012 年出廠, 硬體規格: macOS Catalina Version 10.15.4 1.8 GHz Dual-Core Intel Core i5 Memory $GB 1600 MHz DDR3 Graphics Intel HD Graphics 4000 1536 MB 的操作為例, 如何存活在機械設計工程系與精密機械工程科的網際內容管理課程. 由於網際內容管理課程主要以 Ｗindows 10 64 位元操作系統中的 Python 3 可攜程式環境使用為主. 從官方網站下載安裝 Python3 因此 Catalina 系統中的首要任務, 便是安裝 Python 3: 在 2020.05.15 從 https://www.python.org/downloads/mac-osx/ 可以下載安裝最新的 Python 3.8.3 解譯環境. 安裝 pip3 有了 python 3 環境之後, 就可以從 Lanuchpad -> Other -> Terminal 開啟終端機, 並從 get-pip.py 下載用來安裝 pip3 的程式碼, 以終端機上的指令進行安裝: 1 sudo python3 get-pip.py 安裝 pip3 之後, 可以安裝 CMSiMDE 所需的 flask, flask_cors, lxml, bs4, markdown, pelican 以及 leo: 1 sudo pip3 install flask flask_cors lxml bs4 markdown pelican leo 安裝 XQuartz 之後, 就可以安裝 XQuartz, 以便使用 xterm 替代 terminal. 接下來假如要使用 SciTE 作為文字編輯器, 建議透過 https://www.macports.org/install.php 先根據 Catalina 操作系統版本安裝 Macports 之後, 再利用: 1 sudo port install scite 安裝 SciTE 文字編輯器. 至此, 再加上 Catalina 原有的 git 指令, 使用者已經可以在 MacBook 上執行與 Windows 10 64 位元操作系統上相同的: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 git clone --recurse-submodules git add . git commit -m \"commit message\" git push git pull git submodule add git remote add git branch git merge 等指令, 只是在執行 python 程式時, 必須使用: 1 2 3 python3 wsgi.py pip3 install certain_module 否則直接使用 python 執行, 將會用 Python 2.7 環境執行而產生錯誤. 其他建議安裝套件 Microsoft Remote Desktop Firefox OBS Visual Studio Code Visual Studio Code Distilled.pdf (for @gm users only) Flutter (Dart) 其他提示 Command + Shift + . (toggle hidden folders and files) Mac OS X for Absolute Beginners.pdf (for @gm users only) Learn C on the Mac.pdf (for @gm users only) 這裡以 MacBook Air 2012 年出廠, 硬體規格: macOS Catalina Version 10.15.4 1.8 GHz Dual-Core Intel Core i5 Memory $GB 1600 MHz DDR3 Graphics Intel HD Graphics 4000 1536 MB 的操作為例, 如何存活在機械設計工程系與精密機械工程科的網際內容管理課程. 由於網際內容管理課程主要以 Ｗindows 10 64 位元操作系統中的 Python 3 可攜程式環境使用為主. 從官方網站下載安裝 Python3 因此 Catalina 系統中的首要任務, 便是安裝 Python 3: 在 2020.05.15 從 https://www.python.org/downloads/mac-osx/ 可以下載安裝最新的 Python 3.8.3 解譯環境. 安裝 pip3 有了 python 3 環境之後, 就可以從 Lanuchpad -> Other -> Terminal 開啟終端機, 並從 get-pip.py 下載用來安裝 pip3 的程式碼, 以終端機上的指令進行安裝: 1 sudo python3 get-pip.py 安裝 pip3 之後, 可以安裝 CMSiMDE 所需的 flask, flask_cors, lxml, bs4, markdown, pelican 以及 leo: 1 sudo pip3 install flask flask_cors lxml bs4 markdown pelican leo 安裝 XQuartz 之後, 就可以安裝 XQuartz, 以便使用 xterm 替代 terminal. 接下來假如要使用 SciTE 作為文字編輯器, 建議透過 https://www.macports.org/install.php 先根據 Catalina 操作系統版本安裝 Macports 之後, 再利用: 1 sudo port install scite 安裝 SciTE 文字編輯器. 至此, 再加上 Catalina 原有的 git 指令, 使用者已經可以在 MacBook 上執行與 Windows 10 64 位元操作系統上相同的: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 git clone --recurse-submodules git add . git commit -m \"commit message\" git push git pull git submodule add git remote add git branch git merge 等指令, 只是在執行 python 程式時, 必須使用: 1 2 3 python3 wsgi.py pip3 install certain_module 否則直接使用 python 執行, 將會用 Python 2.7 環境執行而產生錯誤. 其他建議安裝套件 Microsoft Remote Desktop Firefox OBS Visual Studio Code Visual Studio Code Distilled.pdf (for @gm users only) Flutter (Dart) 其他提示 Command + Shift + . (toggle hidden folders and files)","tags":"Misc","url":"./2020-Fall-w10-bit-Windows.html"},{"title":"2020 Fall CP 課程W11","text":"以 SSH 維護倉儲 W10 - W11 由於在電腦教室時採用純 IPv6 協定上網, 因此為了能夠在近端將倉儲改版資料推送到目前只接受 IPv4 協定連線的 github, 以下除了將原本以 https 對 github 連線, 改為以 ssh 協定連線外, 在 Windows 環境下必須利用 putty 與 plink, 設定 putty 格式的 .ppk 以及能夠同時支援 IPv4 與 IPv6 的代理主機. 設定步驟如下: 下載 Putty 工具組 從 https://www.chiark.greenend.org.uk/~sgtatham/putty/ 下載一般版, 或從 http://jakub.kotrla.net/putty/ 下載特殊的可攜版本. 利用 y:\\portablegit\\bin\\sh.exe 進入 shell 命令環境後, 以 1 ssh-keygen -t rsa -b 4096 -C \"使用者學號\" 在 /y/home/.ssh 目錄下建立 id_rsa 與 id_rsa.pub 等 private key 與 public key 之後以 SciTE 開啟 id_rsa.pub 後, 將此 public key 的內容, 以新增添加到 Github.com 帳號下 personal settings -> SSH and GPG keys 頁面下. 接下來要利用 puttygen.exe 將 id_rsa 轉為 Putty 可以解讀的 .ppk 格式, 並修改隨身系統的啟動批次檔案, 指定利用 putty 目錄下的 plink 執行 git 指令的網路代理設定. 1 2 3 4 修改啟動的 start.bat 加入下列設定: set GIT_HOME=%Disk%:\\portablegit\\bin\\ set GIT_SSH=%Disk%:\\putty\\plink.exe 4. 利用 puttygen.exe 載入第二步驟所建立的 private key, 也就是 id_rsa. 開啟 puttygen 之後, 以右下方的 load 載入 id_rsa, 成功載入後, 利用 save private key 按鈕, 將已經轉為 putty 格式的 .ppk 存檔. 此一 .ppk 檔案必須在設定 putty 中 github.com session 時, 在 Connection->SSH->Auth 項目下, 將轉檔後的 .ppk 指向 private key file for authentication 欄位. 並在 Connection->Proxy 項目下, 指定 Proxy type: HTTP, 並將 IPv6 代理主機設為 ::53 或 ::42 埠號設為 3128. 之後確定 home 下的 .ssh 目錄中的 config 設定檔案為: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 no proxy at home ProxyCommand y:/PortableGit/mingw64/bin/connect.exe -H proxy.mde.nfu.edu.tw:3128 %h %p set git_ssh=y:/putty/plink.exe with auth under putty github.com session setup ProxyCommand y:/putty/plink.exe github.com %h %p Host github.com User git Port 22 Hostname github.com # for connect . exe need openssh key format # IdentityFile \"y:\\home\\.ssh\\id_rsa_mdecourse\" # for plink . exe need rsa key format but set under putty github . com session # plink . exe do not need the following setting # IdentityFile \"y:\\home\\.ssh\\mdecourse_putty_private.ppk\" TCPKeepAlive yes IdentitiesOnly yes 最後再將 wcmj2020 倉儲中 .git 目錄下的 config 檔案中的連線協定, 由 https 改為採 ssh 連線: 範例如下: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 [core] repositoryformatversion = 0 filemode = false bare = false logallrefupdates = true symlinks = false ignorecase = true [submodule] active = . [remote \"origin\"] #url = https://github.com/mdecourse/wcmj2020.git url = git@github.com:mdecourse/wcmj2020.git fetch = +refs/heads/ :refs/remotes/origin/ [branch \"master\"] remote = origin merge = refs/heads/master [submodule \"cmsimde\"] url = https://github.com/mdecourse/cmsimde.git 之後就可以透過近端的 .ppk private key 與 Github.com 上的 public key 對應, 無需輸入帳號密碼就可以進行 git push. W10 以 ssh 對倉儲連線設定說明影片 (登入 @gm 帳號後觀看) Mac OS X for Absolute Beginners.pdf (for @gm users only) Learn C on the Mac.pdf (for @gm users only) 這裡以 MacBook Air 2012 年出廠, 硬體規格: macOS Catalina Version 10.15.4 1.8 GHz Dual-Core Intel Core i5 Memory $GB 1600 MHz DDR3 Graphics Intel HD Graphics 4000 1536 MB 的操作為例, 如何存活在機械設計工程系與精密機械工程科的網際內容管理課程. 由於網際內容管理課程主要以 Ｗindows 10 64 位元操作系統中的 Python 3 可攜程式環境使用為主. 從官方網站下載安裝 Python3 因此 Catalina 系統中的首要任務, 便是安裝 Python 3: 在 2020.05.15 從 https://www.python.org/downloads/mac-osx/ 可以下載安裝最新的 Python 3.8.3 解譯環境. 安裝 pip3 有了 python 3 環境之後, 就可以從 Lanuchpad -> Other -> Terminal 開啟終端機, 並從 get-pip.py 下載用來安裝 pip3 的程式碼, 以終端機上的指令進行安裝: 1 sudo python3 get-pip.py 安裝 pip3 之後, 可以安裝 CMSiMDE 所需的 flask, flask_cors, lxml, bs4, markdown, pelican 以及 leo: 1 sudo pip3 install flask flask_cors lxml bs4 markdown pelican leo 安裝 XQuartz 之後, 就可以安裝 XQuartz, 以便使用 xterm 替代 terminal. 接下來假如要使用 SciTE 作為文字編輯器, 建議透過 https://www.macports.org/install.php 先根據 Catalina 操作系統版本安裝 Macports 之後, 再利用: 1 sudo port install scite 安裝 SciTE 文字編輯器. 至此, 再加上 Catalina 原有的 git 指令, 使用者已經可以在 MacBook 上執行與 Windows 10 64 位元操作系統上相同的: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 git clone --recurse-submodules git add . git commit -m \"commit message\" git push git pull git submodule add git remote add git branch git merge 等指令, 只是在執行 python 程式時, 必須使用: 1 2 3 python3 wsgi.py pip3 install certain_module 否則直接使用 python 執行, 將會用 Python 2.7 環境執行而產生錯誤. 其他建議安裝套件 Microsoft Remote Desktop Firefox OBS Visual Studio Code Visual Studio Code Distilled.pdf (for @gm users only) Flutter (Dart) 其他提示 Command + Shift + . (toggle hidden folders and files)","tags":"Misc","url":"./2020-Fall-w11-bit-Windows.html"},{"title":"2018 Fall CP 課程","text":"2018 Fall 一開始, 在一台已經 10 年的 32 位元的 Windows 7 操作系統中工作. 可攜的 Python 3.7.0 仍然可以配置, Leo Editor、PyQt5、flask、Markdown、pelican 與 bs4 的安裝, 也都沒有問題. 只有 Eric6 因為缺少必要模組與 Python 3.7.0 對應的 pyqt5-tools, 因此沒有安裝. 電腦規格 目前系上已經沒有 32 位元 Windows 操作系統的電腦, 所以先前只要有學生提到所使用的電腦是舊型 32 位元的 Windows XP 或 Windows 7, 都無法提供相應的可攜程式系統. 但是, 當您桌上就只一台早期 Sony 推出的 VGC-LM26T 電腦, 採用 Intel core 2 Duo T8100 2.1 GHz 裝載 32 位元 Windows 7, 記憶體只有 2GB 的老舊電腦. 夠用嗎? 當然可以, 使用的是特別製作的 32 位元可攜系統 , 除了不支援 Eric6 之外, 其餘功能都與 64 位元的 p37 相同. 工作流程 從 2018 Fall 開始, 前半學期希望每位計算機程課程的學員, 都能透過 2018 計算機程式教材 內容, 深入學習 Python 3 各種程式語法, 利用 CMSimfly 、 Pelican 與 Reveal.js , 熟悉如何在 Github 配置自己的網站、網誌與網際簡報系統. 使用時, 啟動隨身系統的 start.bat, 利用命令列指令, git clone https://github.com/mdecourse/2018fall, 然後將內容配置在各自的 Github 帳號下. 程式專案 早在 1999 年, 就已經開始進行所謂 網際機械設計資源中心 的構建, 想像中的資源中心是一套網際專家系統, 包含各式機械設計流程中所需的模組, 全部依附在一個相對穩定, 可以持續改進的核心架構下, 類似 docassemble 的一套系統. 將近二十年過去, 網際機械設計資源中心 始終仍只有片段系統, 其中包含 CMSimfly 、 Pygrouf 與 Pyslvs ( Pyslvs 手冊 )等相關專案. 就如同 如何寫出有用的程式? 一文中所述, \"沒有興趣不要來念資工\" 是一句非常貼切的警語, 當學生對於程式設計提不起興趣, 沒有將所學的各式語法、資料結構與演算法, 套用在自己非常有興趣的領域中, 用來解決各式問題的話, 日復一日, 我們還是寫不出任何有用的程式! 早該起頭的重要工作 計算機程式的重要性 其實已經無需爭辯, 人類未來的許多工作都是透過網路與數位運算達成, 既知趨勢如此, 每一位工程師就該越早起頭原本就該進行的重要工作, 透過計算機程式來解決問題, 構築一個值得長期投注心力的程式專案. 目前系上已經沒有 32 位元 Windows 操作系統的電腦, 所以先前只要有學生提到所使用的電腦是舊型 32 位元的 Windows XP 或 Windows 7, 都無法提供相應的可攜程式系統. 但是, 當您桌上就只一台早期 Sony 推出的 VGC-LM26T 電腦, 採用 Intel core 2 Duo T8100 2.1 GHz 裝載 32 位元 Windows 7, 記憶體只有 2GB 的老舊電腦. 夠用嗎? 當然可以, 使用的是特別製作的 32 位元可攜系統 , 除了不支援 Eric6 之外, 其餘功能都與 64 位元的 p37 相同. 工作流程 從 2018 Fall 開始, 前半學期希望每位計算機程課程的學員, 都能透過 2018 計算機程式教材 內容, 深入學習 Python 3 各種程式語法, 利用 CMSimfly 、 Pelican 與 Reveal.js , 熟悉如何在 Github 配置自己的網站、網誌與網際簡報系統. 使用時, 啟動隨身系統的 start.bat, 利用命令列指令, git clone https://github.com/mdecourse/2018fall, 然後將內容配置在各自的 Github 帳號下. 程式專案 早在 1999 年, 就已經開始進行所謂 網際機械設計資源中心 的構建, 想像中的資源中心是一套網際專家系統, 包含各式機械設計流程中所需的模組, 全部依附在一個相對穩定, 可以持續改進的核心架構下, 類似 docassemble 的一套系統. 將近二十年過去, 網際機械設計資源中心 始終仍只有片段系統, 其中包含 CMSimfly 、 Pygrouf 與 Pyslvs ( Pyslvs 手冊 )等相關專案. 就如同 如何寫出有用的程式? 一文中所述, \"沒有興趣不要來念資工\" 是一句非常貼切的警語, 當學生對於程式設計提不起興趣, 沒有將所學的各式語法、資料結構與演算法, 套用在自己非常有興趣的領域中, 用來解決各式問題的話, 日復一日, 我們還是寫不出任何有用的程式! 早該起頭的重要工作 計算機程式的重要性 其實已經無需爭辯, 人類未來的許多工作都是透過網路與數位運算達成, 既知趨勢如此, 每一位工程師就該越早起頭原本就該進行的重要工作, 透過計算機程式來解決問題, 構築一個值得長期投注心力的程式專案.","tags":"Misc","url":"./2018-Fall-32-bit-Windows.html"}]};