var tipuesearch = {"pages": [{'title': '有關本網站', 'text': '\n 這門課程在教導學員如何利用網際環境管理與工程應用相關的內容管理 \n 總共使用兩套網際內容管理系統: \n https://github.com/mdecourse/cmsimde \n https://www.blogger.com/ \n Please use your student number to \xa0 register a github account . \n 請利用學號註冊一個 Github 帳號 \n Repository (倉儲): \xa0 https://github.com/mdecourse/wcmj2020 \xa0 \n Project (專案): \xa0 https://github.com/mdecourse/wcmj2020/projects/1 \xa0 \n Gitter (討論區): \xa0 https://gitter.im/mdecourse/wcmj2020 \xa0 \n Web site (網站):\xa0 https://mde.tw/wcmj2020 \xa0 \n Blog (網誌): \xa0 https://mde.tw/wcmj2020/blog \xa0 \n Presentation (簡報): \xa0 https://mde.tw/wcmj2020/reveal \xa0 \n 電腦輔助設計室與協同設計室行事曆 \n 全頁檢視 \n \n 請登入 gm 電子郵箱後, 填寫下列表單: \n 選課學員基本資料 \n 課程回饋表單 \n 網際內容管理自評與互評表單 \n Next \xa0 >> CMSiMDE \n \n \n Copyright ©2020 All rights reserved | This template is made with \xa0 \xa0 by \xa0 Colorlib \n \n \n 此內容管理系統以\xa0 https://github.com/mdecourse/cmsimde \xa0作為 submodule 運作, 可以選定對應的版本運作, cmsimde 可以持續改版, 不會影響之前設為 submodule, 使用舊版 cmsimde 模組的內容管理相關運作. \n 利用 cmsimde 建立靜態網誌方法: \n 1. 在 github 建立倉儲, git clone 到近端 \n 2. 參考\xa0 https://github.com/mdecourse/newcms , 加入除了 cmsimde 目錄外的所有內容 \n 以 git submodule add\xa0 https://github.com/mdecourse/cmsimde \xa0cmsimde \n 建立 cmsimde 目錄, 並從 github 取下子模組內容. \n 3.在近端維護時, 更換目錄到倉儲中的 cmsimde, 以 python wsgi.py 啟動近端網際伺服器. \n 動態內容編輯完成後, 以 generate_pages 轉為靜態內容, 以 git add commit 及 push 將內容推到遠端. \n 4. 之後若要以 git clone 取下包含 submodule 的所有內容, 執行: \n git clone --recurse-submodules  https://github.com/mdecourse/newcms.git \n \n \n', 'tags': '', 'url': '有關本網站.html'}, {'title': 'Develop', 'text': 'https://github.com/mdecourse/cmsimde \xa0的開發, 可以在一個目錄中放入 cmsimde, 然後將 up_dir 中的內容放到與 cmsimde 目錄同位階的地方, 使用 command 進入 cmsimde 目錄, 執行 python wsgi.py, 就可以啟動, 以瀏覽器 https://localhost:9443\xa0就可以連接, 以 admin 作為管理者密碼, 就可以登入維護內容. \n cmsimde 的開發採用 Leo Editor, 開啟 cmsimde 目錄中的 cmsimde.leo 就可以進行程式修改, 結束後, 若要保留網際內容, 只要將 cmsimde 外部的內容倒回 up_dir 目錄中即可後續對 cmsimde 遠端倉儲進行改版. \n init.py 位於\xa0 up_dir 目錄, 可以設定 site_title 與 uwsgi 等變數. \n', 'tags': '', 'url': 'Develop.html'}, {'title': 'C 程式', 'text': '前面所打造的可攜 Python 程式環境, 包括 SciTE 文字編輯器, 只要再加上 \xa0 https://bellard.org/tcc/ , 可將此一可攜環境設置成能夠編譯與類解譯 ANSI C 程式的環境 \n C 程式語言教材: \n Programming-in-ANSI-C.pdf \n gnu_c_programming_tutorial.pdf \n \n', 'tags': '', 'url': 'C 程式.html'}, {'title': '可攜程式環境', 'text': '為了讓工程師可以在不同的 Windows 10 64 位元電腦上管理 CMSiMDE 網際內容管理系統, 因此需要 Python 解譯環境以及一個文字檔案的編輯器. \n 這裡所安裝的 Python 解譯器選擇由 C 所編寫的 CPython, 可以從 \xa0 https://www.python.org/ \xa0 下載安裝. 但是在此我們要將 Python 解譯系統配置在 USB 隨身碟上, 使用者可以隨身攜帶, 一旦配置完成後, 可以在任何一台 Windows 10 64 位元的筆電或電腦上執行 Python 或 C 程式. \n 可攜 Python 程式環境的建立步驟: \n 安裝 Python 套件時, 不要安裝 pip, 之後將 Python38 目錄複製到 data 目錄中, 然後建立 start.bat 指定使用可攜系統中的 Python, 之後再利用 g et-pip.py, \xa0 以命令列中的 python get-pip.py 安裝 pip. \n 可攜 Tiny C 程式環境的建立步驟: \n 從 \xa0 https://bellard.org/tcc/ \xa0 下載 Tiny C, 將 tcc 解開壓縮後放到 data 目錄中. 然後修改 wscite 目錄中的 cpp.properties, 使用 Tiny C 類解譯 .c 程式. \n 選用的文字編輯器: \xa0 https://www.scintilla.org/SciTE.html \n 建立完成的可攜程式環境: \n 下載\xa0 wcm2020_w2.7z (舊資料) \n 請重新下載 \xa0 wcmj2020_tool.7z , 檔案大小為 435 MB, 解開壓縮後為 1.8 GB (其中包括 Mypaint, Dia 與 OBS 等) \n 將 wcmj2020_tool.7z 解壓縮到隨身碟或電腦硬碟中, 將 home 與 home_ipv6 目錄中的 .gitconfig user.name 與 user.email 改為自己的 Github 帳號與 email 後, 利用 start.bat 啟動可攜系統, 利用 stop.bat 關閉可攜系統. \n CMSiMDE << \xa0 Previous \xa0 Next \xa0 >> C 程式\n \n \n Copyright ©2020 All rights reserved | This template is made with \xa0 \xa0 by \xa0 Colorlib \n \n', 'tags': '', 'url': '可攜程式環境.html'}, {'title': '分組', 'text': '亂數分組: \n https://mde.tw/wcmj2020/downloads/2020spring_wcmj_1a_list.txt \xa0was taken from\xa0 https://osa.nfu.edu.tw/ \xa0on Feb. 19, 2020. \n The most updated list:\xa0 http://s1.mde.nfu.edu.tw:8000/?semester=1082&courseno=2418 \xa0 \n semester: 1082 \n courseno: 2418 \n Under https protocol use port 7443, for http use port 8000. \n 學員名單 URL: \xa0 \n Dart source code for random grouping \n evenGrouping.dart: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n 69 \n 70 \n 71 \n 72 \n 73 \n 74 \n 75 \n 76 \n 77 \n 78 \n 79 \n 80 \n 81 \n 82 \n 83 \n 84 \n 85 \n 86 \n 87 \n 88 \n 89 \n 90 \n 91 \n 92 \n 93 \n 94 \n 95 \n 96 \n 97 \n 98 \n 99 \n 100 \n 101 \n 102 \n 103 \n 104 \n 105 \n 106 \n 107 \n 108 \n 109 \n 110 \n 111 \n 112 \n 113 \n 114 \n 115 \n 116 \n 117 \n 118 \n 119 \n 120 \n 121 \n 122 \n 123 \n 124 \n 125 \n 126 \n 127 \n 128 \n 129 \n 130 \n 131 \n 132 \n 133 \n 134 \n 135 \n 136 \n 137 \n 138 \n 139 \n 140 \n 141 \n \n \n \n import   \'dart:html\' ; \n \xa0 \xa0 \n \xa0\xa0 InputElement studListUrl = querySelector( "#studListUrl" ); \n \xa0\xa0 String studUrl; \n \xa0\xa0 // 將 Label 改為 Textarea, 避免產生過程結果嵌入所在頁面 \n \xa0\xa0 TextAreaElement output = querySelector( "#output" ); \n \xa0 \xa0 \n main() { \n \xa0\xa0 querySelector( "#submit" ).onClick.listen((e) => grouping()); \n } \n \xa0 \xa0 \n grouping() { \n \xa0\xa0 output.innerHtml =  "" ; \n \xa0 \xa0 \n \xa0\xa0 if   (studListUrl.value !=  "" ) { \n \xa0\xa0\xa0\xa0 studUrl = studListUrl.value; \n \xa0\xa0 }  else   { \n \xa0\xa0\xa0\xa0 studUrl =  \'https://mde.tw/group/downloads/2019fall_cp_1a_list.txt\' ; \n \xa0\xa0 } \n \xa0 \xa0 \n \xa0\xa0 // 組序由 1 開始 \n \xa0\xa0 int gth = 1; \n \xa0\xa0 // 迴圈序號變數 \n \xa0\xa0 int i; \n \xa0\xa0 int j; \n \xa0\xa0 int total; \n \xa0\xa0 int inc; \n \xa0\xa0 // 每組學員暫存數列 \n \xa0\xa0 var gpList = []; \n \xa0\xa0 // 全班分組數列 \n \xa0\xa0 var group = []; \n \xa0\xa0 // 各組人數數列 \n \xa0\xa0 var numList = []; \n \xa0\xa0 var courseTitle =  \'wcmj2020\' ; \n \xa0 \xa0 \n \xa0\xa0 HttpRequest.getString(studUrl).then((String resp) { \n \xa0\xa0\xa0\xa0 // 利用 trim() 去除字串最後的跳行符號, 之後再利用 split() 根據 \\n 轉為數列 \n \xa0\xa0\xa0\xa0 var studList = resp.trim().split( "\\n" ); \n \xa0\xa0\xa0\xa0 // 數列利用 shuffle() 方法以隨機方法弄亂順序 \n \xa0\xa0\xa0\xa0 studList.shuffle(); \n \xa0\xa0\xa0\xa0 total = studList.length; \n \xa0\xa0\xa0\xa0 output.text +=  "全班總計"   + total.toString() +  " 人\\n" ; \n \xa0\xa0\xa0\xa0 numList = getNumList(studList.length); \n \xa0\xa0\xa0\xa0 inc = 0; \n \xa0\xa0\xa0\xa0 for   (i  in   numList){ \n \xa0\xa0\xa0\xa0\xa0\xa0 // 列印區隔符號 \n \xa0\xa0\xa0\xa0\xa0\xa0 output.text +=  \'=\'   * 20 +  "\\n" ; \n \xa0\xa0\xa0\xa0\xa0\xa0 output.text +=  "group $gth 有 "   + i.toString() +  " 人: \\n" ; \n \xa0\xa0\xa0\xa0\xa0\xa0 gpList = []; \n \xa0\xa0\xa0\xa0\xa0\xa0 for   (j = 0; j < i; j++){ \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 output.text += studList[j+inc] +  "\\n" ; \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 // 在各分組數列中加入將對應的學員學號 \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 gpList.add(studList[j+inc]); \n \xa0\xa0\xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0\xa0\xa0 gth = gth + 1; \n \xa0\xa0\xa0\xa0\xa0\xa0 inc = inc + j; \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 //output.text += studList[j] + "\\n"; \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 // 逐步將各組暫存的分組數列加入全班分組數列中 \n \xa0\xa0\xa0\xa0\xa0\xa0 gpList.sort(); \n \xa0\xa0\xa0\xa0\xa0\xa0 group.add(gpList); \n \xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0 // 列出全班分組數列 \n \xa0\xa0\xa0\xa0 output.text += group.toString() +  "\\n" ; \n \xa0\xa0\xa0\xa0 // 列出已經排序後的分組名單 \n \xa0\xa0\xa0\xa0 output.text +=  \'=\'   * 25 +  "\\n" ; \n \xa0\xa0\xa0\xa0 output.text +=  \'以下為排序後的各組成員名單: \\n\' ; \n \xa0\xa0\xa0\xa0 gth = 1; \n \xa0\xa0\xa0\xa0 /* \n \xa0\xa0\xa0\xa0 404231 \n \xa0\xa0\xa0\xa0 s4052 \n \xa0\xa0\xa0\xa0 4062 \n \xa0\xa0\xa0\xa0 s4072 \n \xa0\xa0\xa0\xa0 4082 \n \xa0\xa0\xa0\xa0 5072 \n \xa0\xa0\xa0\xa0 5083 \n \xa0\xa0\xa0\xa0 */ \n \xa0\xa0\xa0\xa0 // 先列出純文字以 \\n 跳行組員資料 \n \xa0\xa0\xa0\xa0 for   (i=0; i < group.length; i++){ \n \xa0\xa0\xa0\xa0\xa0\xa0 // 列印區隔符號 \n \xa0\xa0\xa0\xa0\xa0\xa0 output.text +=  \'=\'   * 20 +  "\\n" ; \n \xa0\xa0\xa0\xa0\xa0\xa0 output.text +=  "group $gth \\n" ; \n \xa0\xa0\xa0\xa0\xa0\xa0 gpList = []; \n \xa0\xa0\xa0\xa0\xa0\xa0 for   (j=0; j < group[i].length; j++){ \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 output.text += group[i][j] +  "\\n" ; \n \xa0\xa0\xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0\xa0\xa0 gth = gth + 1; \n \xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 gth = 1; \n \xa0\xa0\xa0\xa0 // 最後列出超文件以 <br\\> 跳行組員資料, 包含倉儲與網站 \n \xa0\xa0\xa0\xa0 for   (i=0; i < group.length; i++){ \n \xa0\xa0\xa0\xa0\xa0\xa0 // 列印區隔符號 \n \xa0\xa0\xa0\xa0\xa0\xa0 output.text +=  \'\\n\'   +  \'=\'   * 30 +  "<br \\>" ; \n \xa0\xa0\xa0\xa0\xa0\xa0 output.text +=  "group $gth <br \\>" ; \n \xa0\xa0\xa0\xa0\xa0\xa0 gpList = []; \n \xa0\xa0\xa0\xa0\xa0\xa0 for   (j=0; j < group[i].length; j++){ \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 if   (group[i][j].startsWith( \'4052\' ) || group[i][j].startsWith( \'4072\' )) { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 output.text +=  "Repository: <a href=\'https://github.com/s"   +  \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 group[i][j] +  "/"   + courseTitle +  "\'>"   + group[i][j] +  \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 "</a>"   +  " | Site: <a href=\'https://s"   + group[i][j] +  \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 ".github.io/"   + courseTitle +  "\'>"   + group[i][j] +  \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 "</a><br \\>" ; \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 else   { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 output.text +=  "Repository: <a href=\'https://github.com/"   +  \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 group[i][j] +  "/"   + courseTitle + "\'>"   + group[i][j] +  \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 "</a>"   +  " | Site: <a href=\'https://"   + group[i][j] +  \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 ".github.io/"   + courseTitle +  "\'>"   + group[i][j] +  \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 "</a><br \\>" ; \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0\xa0\xa0 gth = gth + 1; \n \xa0\xa0\xa0\xa0 } \n \xa0\xa0 }); \n } \n \xa0 \xa0 \n List getNumList(int total){ \n \xa0\xa0 // total student number \n \xa0\xa0 // int total = 65; \n \xa0\xa0 // initial each group expect to be "eachGrp" number of people \n \xa0\xa0 int eachGrp = 10; \n \xa0\xa0 // may divide into "grpNum" number of group \n \xa0\xa0 int grpNum = total ~/ eachGrp; \n \xa0\xa0 // vacant list \n \xa0\xa0 var splits = []; \n \xa0\xa0 // find remainder when total number divid into "grpNum" number of group \n \xa0\xa0 int remainder = total % grpNum; \n \xa0\xa0 // number of people in one group by calculation \n \xa0\xa0 int calGrp = total ~/ grpNum; \n \xa0 \xa0 \n \xa0\xa0 for   (int i = 0; i < grpNum; i++) { \n \xa0\xa0\xa0\xa0 splits.add(calGrp); \n \xa0\xa0 } \n \xa0\xa0 //print(splits); \n \xa0 \xa0 \n \xa0\xa0 for   (int i = 0; i < remainder; i++) { \n \xa0\xa0\xa0\xa0 splits[i] += 1; \n \xa0\xa0 } \n \xa0\xa0 //print(splits); \n \xa0\xa0 return   splits; \n \xa0 } \n \n \n \n \n \n \n \n index.html: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n \n \n \n < h1 >亂數分組:</ h1 > \n 學員名單 URL: < input   type = "text"   id = "studListUrl"   size = "50"   value = "https://mde.tw/wcm2020/downloads/2020spring_wcm_1a_list.txt" >< br   /> \n < input   type = "submit"   value = "開始分組"   id = "submit" >< br   /> \n < textarea   id = "output"   cols = "80"   rows = "10" ></ textarea > \n \n \n \n \n \n \n \n style.css: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n \n \n \n body { \n \xa0\xa0 color :  white ; \n \xa0\xa0 font-size :  20px ; \n } \n \xa0 \n input, select, textarea { \n font-size :  100% ; \n } \n \n \n \n \n \n \n \n get_student.py \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n 69 \n 70 \n 71 \n 72 \n 73 \n \n \n \n from   flask  import   Flask, request  \n from   flask_cors  import   CORS \n \xa0 \n import   requests \n import   bs4 \n import   ssl \n \xa0 \n \'\'\' \n https://s1.mde.nfu.edu.tw:7443/?semester=1082&courseno=0767 \n cd \n 2a 1082/0767 \n 2b 1082/0780 \n \xa0 \n 2a 1072/0777 \n 2b 1072/0790 \n 2a 1062/0788 \n 2a 1062/0802 \n \xa0 \n wcm \n 1082/0744 \n \xa0 \n 1072/0754 \n 1062/0765 \n \xa0 \n wcmj \n 1082/2418 \n \'\'\' \n \xa0 \n app  =   Flask(__name__) \n CORS(app) \n \xa0 \n @app .route( \'/studlist\' ) \n @app .route( \'/\' ) \n def   studlist(): \n \xa0\xa0\xa0\xa0 semester  =   request.args.get( \'semester\' ) \n \xa0\xa0\xa0\xa0 courseno  =   request.args.get( \'courseno\' ) \n \xa0\xa0\xa0\xa0 if   semester  = =   None : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 semester  =   \'1082\' \n \xa0\xa0\xa0\xa0 if   courseno  = =   None : \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 courseno  =   \'0744\' \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 url  =   \'https://osa.nfu.edu.tw/query/studlist_ajax.php\' \n \xa0\xa0\xa0\xa0 post_var  =   { \'pselyr\' : semester,  \'pseqno\' : courseno} \n \xa0 \n \xa0\xa0\xa0\xa0 result  =   requests.post(url, data  =   post_var) \n \xa0 \n \xa0\xa0\xa0\xa0 soup  =   bs4.BeautifulSoup(result.content,  \'lxml\' ) \n \xa0\xa0\xa0\xa0 table  =   soup.find( \'table\' , { \'class\' :  \'tbcls\' }) \n \xa0\xa0\xa0\xa0 data  =   [] \n \xa0\xa0\xa0\xa0 rows  =   table.find_all( \'tr\' ) \n \xa0\xa0\xa0\xa0 for   row  in   rows: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 cols  =   row.find_all( \'td\' ) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 cols  =   [ele.text.strip()  for   ele  in   cols] \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 data.append([ele  for   ele  in   cols  if   ele])  # Get rid of empty values \n \xa0\xa0\xa0\xa0 output  =   "" \n \xa0\xa0\xa0\xa0 for   i  in   data[ 2 :]: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 #print(i[0]) \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 output  + = i[ 0 ]  +   "\\n" \n \xa0\xa0\xa0\xa0 return   output \n \xa0\xa0\xa0\xa0 #return\xa0 str(pselyr) + " + " +str(pseqno) \n \xa0 \n # 即使在近端仍希望以 https 模式下執行 \n context  =   ssl.SSLContext(ssl.PROTOCOL_TLSv1_2) \n context.load_cert_chain( \'localhost.crt\' ,  \'localhost.key\' ) \n \xa0 \n # 取 flaskapp.py 中的 uwsgi 變數設定 \n uwsgi  =   False \n if   uwsgi: \n \xa0\xa0\xa0\xa0 # 表示程式在雲端執行 \n \xa0\xa0\xa0\xa0 application  =   app \n else : \n \xa0\xa0\xa0\xa0 # 表示在近端執行, 以 python3 wsgi.py 執行 \n \xa0\xa0\xa0\xa0 app.run(host = \'127.0.0.1\' , port = 5443 , debug = True , ssl_context = context) \n \n \n \n \n \n \n \n nginx sites-available/default settings: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n \n \n \n server { \n \xa0\xa0\xa0\xa0 listen 8000; \n \xa0\xa0\xa0\xa0 server_name s1.mde.nfu.edu.tw; \n \xa0\xa0\xa0\xa0 charset utf-8; \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 listen 7443 ssl; \n \xa0 \xa0 \n \xa0\xa0\xa0\xa0 location /static { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 alias /home/kmol2019/course_studlist/static/; \n \xa0\xa0\xa0\xa0 } \n \xa0 \xa0 \n \xa0\xa0\xa0\xa0 location / { \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 include uwsgi_params; \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 uwsgi_pass\xa0 127.0.0.1:8087; \n \xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 ssl_certificate /etc/stunnel/localhost.crt; \n \xa0\xa0\xa0\xa0 ssl_certificate_key /etc/stunnel/localhost.key; \n \xa0\xa0\xa0\xa0 ssl_session_timeout 5m; \n \xa0\xa0\xa0\xa0 ssl_protocols SSLv3 TLSv1 TLSv1.1 TLSv1.2; \n \xa0\xa0\xa0\xa0 ssl_ciphers  "HIGH:!aNULL:!MD5 or HIGH:!aNULL:!MD5:!3DES" ; \n \xa0\xa0\xa0\xa0 ssl_prefer_server_ciphers on; \n \xa0\xa0\xa0\xa0 try_files $uri $uri/ =404; \n } \n \n \n \n \n \n \n \n uwsgi7.ini \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n \n \n \n [uwsgi] \n socket = 127.0.0.1:8087 \n uid = kmol2019 \n gid = kmol2019 \n plugins-dir = /usr/lib/uwsgi/plugins/ \n plugin = python3 \n master =  true \n logto = / var /log/uwsgi/emperor.log \n logfile-chown = kmol2019:kmol2019 \n processes = 4 \n threads = 2 \n chdir = /home/kmol2019/course_studlist \n wsgi-file = /home/kmol2019/course_studlist/get_student.py \n \n \n \n \n \n \n \n /etc/systemd/system/cmsimfly.service \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n \n \n \n [Unit] \n Description=uWSGI to serve CMSimfly \n After=network.target \n \xa0 \n [Service] \n User=kmol2019 \n Group=kmol2019 \n WorkingDirectory=/home/kmol2019/uwsgi_ini \n ExecStart=/usr/local/bin/uwsgi --emperor /home/kmol2019/uwsgi_ini \n \xa0 \n [Install] \n WantedBy=multi-user.target \n \n \n \n \n \n \n \n Python << \xa0 Previous \xa0 Next \xa0 >> 分組結果 \n \n \n Copyright ©2020 All rights reserved | This template is made with \xa0 \xa0 by \xa0 Colorlib \n \n', 'tags': '', 'url': '分組.html'}, {'title': '分組結果', 'text': '各分組學員可以就以下常見的網際內容, 以組員分工的方式深入研究特定主題, 然後再將結果納入 CMSiMDE 網站, 網誌, 簡報 與 Blogger 網誌內容. \n 常見的網際內容包含: \n 文字 (網誌與網站文字說明, 簡報文字敘述) \n 數學方程式 ( mathjax ) \n 圖檔 (png, jpg, gif, \xa0 svg) \n 動畫 (gif) \xa0 \n 音樂 (mp3 or \xa0 midi ) \n 影片 (embedded mp4) \n 程式 \n HTML5 Canvas \xa0 (2d) \n Three.js \xa0 (3D) \n Brython \n fengari-web \xa0 (Lua) \n Dart -> Javascript \n ============================== group 1 Repository: \xa0 50833110 \xa0 | Site: \xa0 50833110 Repository: \xa0 50833112 \xa0 | Site: \xa0 50833112 Repository: \xa0 50833115 \xa0 | Site: \xa0 50833115 Repository: \xa0 50833123 \xa0 | Site: \xa0 50833123 Repository: \xa0 50833127 \xa0 | Site: \xa0 50833127 Repository: \xa0 50833128 \xa0 | Site: \xa0 50833128 Repository: \xa0 50833129 \xa0 | Site: \xa0 50833129 Repository: \xa0 50833131 \xa0 | Site: \xa0 50833131 Repository: \xa0 50833133 \xa0 | Site: \xa0 50833133 Repository: \xa0 50833138 \xa0 | Site: \xa0 50833138 ============================== group 2 Repository: \xa0 50833101 \xa0 | Site: \xa0 50833101 Repository: \xa0 50833107 \xa0 | Site: \xa0 50833107 Repository: \xa0 50833108 \xa0 | Site: \xa0 50833108 Repository: \xa0 50833111 \xa0 | Site: \xa0 50833111 Repository: \xa0 50833117 \xa0 | Site: \xa0 50833117 Repository: \xa0 50833119 \xa0 | Site: \xa0 50833119 Repository: \xa0 50833122 \xa0 | Site: \xa0 50833122 Repository: \xa0 50833126 \xa0 | Site: \xa0 50833126 Repository: \xa0 50833130 \xa0 | Site: \xa0 50833130 Repository: \xa0 50833134 \xa0 | Site: \xa0 50833134 ============================== group 3 Repository: \xa0 50833104 \xa0 | Site: \xa0 50833104 Repository: \xa0 50833106 \xa0 | Site: \xa0 50833106 Repository: \xa0 50833113 \xa0 | Site: \xa0 50833113 Repository: \xa0 50833114 \xa0 | Site: \xa0 50833114 Repository: \xa0 50833116 \xa0 | Site: \xa0 50833116 Repository: \xa0 50833118 \xa0 | Site: \xa0 50833118 Repository: \xa0 50833120 \xa0 | Site: \xa0 50833120 Repository: \xa0 50833125 \xa0 | Site: \xa0 50833125 Repository: \xa0 50833140 \xa0 | Site: \xa0 50833140 Repository: \xa0 50833141 \xa0 | Site: \xa0 50833141 ============================== group 4 Repository: \xa0 50833102 \xa0 | Site: \xa0 50833102 Repository: \xa0 50833103 \xa0 | Site: \xa0 50833103 Repository: \xa0 50833105 \xa0 | Site: \xa0 50833105 Repository: \xa0 50833109 \xa0 | Site: \xa0 50833109 Repository: \xa0 50833121 \xa0 | Site: \xa0 50833121 Repository: \xa0 50833124 \xa0 | Site: \xa0 50833124 Repository: \xa0 50833135 \xa0 | Site: \xa0 50833135 Repository: \xa0 50833136 \xa0 | Site: \xa0 50833136 Repository: \xa0 50833137 \xa0 | Site: \xa0 50833137 Repository: \xa0 50833139 \xa0 | Site: \xa0 50833139 \n 分組 << \xa0 Previous \xa0 Next \xa0 >> 實習項目\n \n \n Copyright ©2020 All rights reserved | This template is made with \xa0 \xa0 by \xa0 Colorlib \n \n', 'tags': '', 'url': '分組結果.html'}, {'title': '期中給我100分', 'text': '', 'tags': '', 'url': '期中給我100分.html'}, {'title': 'w9', 'text': '', 'tags': '', 'url': 'w9.html'}, {'title': '電腦軟體與硬體簡介', 'text': 'Type of Computer： \n super computer 超級電腦 \n MainFrane 伺服器主機 \n Server 伺服器 \n PC 個人電腦 \n Microcontroler 微電腦 \n Mobile Phone 手機 \n \n \n \n 硬體名稱 \n 說明 \n 比喻 \n \n \n CPU \n 中央處理器，電腦的心臟，速度越快效率越好。新一代的電腦甚至可以有多核心（兩個以上的CPU）。 \n 如果將主機比喻為一家商店，那CPU可以說是店員，動作越快、反應越靈巧的店員可以增加銷售的速度。 \n \n \n 記憶體RAM \n 電腦系統運作時暫時儲存資料的地方，其大小也是影響電腦速率快慢的重要因素，建議入門最起碼可以使用2G。因為記憶體大小很重要、而且價格不貴、又不容易損壞，因此「寧可過剩、不要不足」。 \n 猶如商店的賣場面積，賣場越大可以擺的東西越多，客人需要即可直接銷售，而不必進入貨倉中翻箱倒櫃，浪費時間、拖垮效率。 \n \n \n 硬碟 \n 儲存系統軟體、應用軟體以及資料的儲存空間，目前一般大小約為數百G，一台主機可以裝多顆硬碟。 \n 猶如貨倉的大小，貨倉越大當然可以囤積的商品越多。 \n \n \n 光碟機、 燒錄機 \n 光碟機：只能讀取CD、DVD（含音樂、影片及資料），古董機。 燒錄機：本身已經具備讀取功能，並且能夠將各類檔案燒錄於光碟片上，並製作為音樂CD、影片DVD、或純粹備份資料片等，為目前的主流規格。 \n \xa0 \n \n \n 讀卡機 \n 擁有不同的插槽、能夠讀取多種格式的記憶卡。 \n \xa0 \n \n \n \n', 'tags': '', 'url': '電腦軟體與硬體簡介.html'}, {'title': '免費軟體 (Freeware)', 'text': '泛指一切不用金錢買回來的電腦軟體。開發者一般是因興趣或以分享性質而發放。亦有部份是因為不滿或希望改善現存軟體而自行開發另一個或替其最佳化程式。 \n', 'tags': '', 'url': '免費軟體 (Freeware).html'}, {'title': '共享軟體 (Shareware)', 'text': '免費共用軟體，通常有「限期」或「功能限制」或是有條件免費使用 (如：附加廣告)。有些軟體的「試用版」也以共享軟體的形式於網路間分享以及提供下載。 \n', 'tags': '', 'url': '共享軟體 (Shareware).html'}, {'title': '綠色軟體 (Greenware)', 'text': '指一種免費、免安裝軟體，一般在網路上以無條件的方式發放的小型軟體。優點是檔案比較細小﹑不用安裝﹑刪除方便和只佔用少量系統資源，所以甚至可以放在 MP3 播放器或隨身碟中讀取。大部份綠色軟體更是開放源碼並不設權限、歡迎任何人士參與修改或增加功能。(不過也有人將有版權的軟體透過一些技術，將它改成免安裝軟體，也稱為綠色軟體)，此類軟體移除後（直接刪除）也不會將任何紀錄（登錄檔訊息等）留在本機電腦上。 \n', 'tags': '', 'url': '綠色軟體 (Greenware).html'}, {'title': '網路架構與設定簡介', 'text': '第一個步驟:cd tmp \n 再來 cd wcmj2020 \n 第三部:cd cmsimde \n 第四部:python wsgi.py \n 架構: 網路架構模型分為4層，也就是經常聽到的DoD（Department of Defense）或是TCP/IP模型，如附圖所示，最上層為應用層（Application \xa0Layer），接下來依據為傳輸層（Transport Layer）、網路層（Internet Layer）、鏈結層（Link\xa0Layer）。這4層分工需要相互合作，卻又彼此獨立，好比寄信一般，需要郵局處理郵件，道路和交通工具負責運送，信才可送達目的地，但是你卻不用管郵局如何經營、交通工具如何設計、道路怎麼鋪設才會平坦又耐用。 將網路架構分層出來，便加入了許多可能性，只要符合這個網路模型，各層如何處理資訊的方式就各自獨立，不受其它外在條件的限制。舉個小小例子，筆電能夠透過有線和無線方式連上網路，但是這2種傳輸介質所看到的網頁有所差異嗎？應該不會發生有線介面看到Dream Girls，換成無線介面就變閃亮三姊妹這種情形。同時，分層模型所具備的向後相容性也可以在無線傳輸規格上看到，從現今的802.11 a/b/g/n，到未來的802.11 ac/ad，均能夠傳送網頁資料，讀者應該也沒有聽過換個傳輸規格，網頁就要重寫這種荒唐事。 \n', 'tags': '', 'url': '網路架構與設定簡介.html'}, {'title': 'W10', 'text': 'SSH===安全編碼機制 \n Public key 公開密鑰加密器 \n Cryptography 編碼學 \n Putty:EREE SSH FOR WINDOW \n 設置:移動滑鼠 \n ssh-keygen -t rsa -b 4096 -C "50833129" \n pwd:print working directory \n', 'tags': '', 'url': 'W10.html'}, {'title': 'w12-13', 'text': '', 'tags': '', 'url': 'w12-13.html'}, {'title': 'W12', 'text': 'Leo Editor 與 Pelican blog 使用說明影片 \n', 'tags': '', 'url': 'W12.html'}, {'title': 'W13', 'text': 'Pelican Blog 內容與 Google Blogger 同步 \n 利用 Windows 10 設定 -> 選擇預設網頁瀏覽器, 使用 Google Chrome 作為預設瀏覽器. \n 隨身程式系統必須安裝\xa0 google-api-python-client 與 oauth2client pip install google-api-python-client oauth2client OAuth 2.0 client IDs 程式類別可以選擇 other 使用者完成 client_secrets.json 設定後, 必須將檔案存在倉儲目錄外部 \n add_to_blogger 按鈕內容: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n 69 \n 70 \n 71 \n 72 \n 73 \n 74 \n 75 \n 76 \n 77 \n 78 \n 79 \n 80 \n 81 \n 82 \n 83 \n 84 \n 85 \n 86 \n 87 \n 88 \n 89 \n 90 \n 91 \n 92 \n 93 \n 94 \n 95 \n 96 \n \n \n \n from   markdown  import   markdown \n from   oauth2client  import   client \n from   googleapiclient  import   sample_tools \n import   os \n \xa0 \n os.environ[ \'TZ\' ]  =   \'Asia/Taipei\' \n argv  =   "" \n # 認證並建立服務 \n # name of the api is "blogger", version is "v3" \n # description of the api is __doc__ \n # file name of the application: location of client_secrets.json \n service, flags  =   sample_tools.init( \n \xa0\xa0 argv,  \'blogger\' ,  \'v3\' , __doc__,  "./../../client_secrets.json" , \n \xa0\xa0 scope = \'https://www.googleapis.com/auth/blogger\' ) \n \xa0 \n \xa0 \n def   get_cat_tag_content(data): \n \xa0\xa0\xa0\xa0 # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 --- \n \xa0\xa0\xa0\xa0 # 用跳行符號分割 \n \xa0\xa0\xa0\xa0 data_list  =   data.split( "\\n" ) \n \xa0\xa0\xa0\xa0 #第 2 行為 title \n \xa0\xa0\xa0\xa0 title =   data_list[ 1 ] \n \xa0\xa0\xa0\xa0 #第 4 行為 category \n \xa0\xa0\xa0\xa0 category  =   data_list[ 3 ] \n \xa0\xa0\xa0\xa0 #第 5 行為 tags \n \xa0\xa0\xa0\xa0 tags  =   data_list[ 4 ] \n \xa0\xa0\xa0\xa0 # 有多項資料的 content 型別為數列 \n \xa0\xa0\xa0\xa0 # 再將第 9 行之後的資料數列串回成以跳行隔開的資料 \n \xa0\xa0\xa0\xa0 content  =   "\\n" .join(data_list[ 8 :]) \n \xa0\xa0\xa0\xa0 # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 <!--more--> \n \xa0\xa0\xa0\xa0 content  =   content.replace( \'<!-- PELICAN_END_SUMMARY -->\' ,  \'<!--more-->\' ) \n \xa0\xa0\xa0\xa0 # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式 \n \xa0\xa0\xa0\xa0 #content = content.replace(\'~~~python\', \'[code lang="python"]\') \n \xa0\xa0\xa0\xa0 #content = content.replace(\'~~~\', \'[/code]\') \n \xa0\xa0\xa0\xa0 return   title, category, tags, content \n \xa0 \n # 從目前所在節點的 body pan 中取出類別, tags 以及文章內容 \n # p.h 為 @clean filename.md \n # 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案 \n md_filename  =   p.h.split( " " )[ 1 ] \n with  open (md_filename,  \'r\' , encoding = "utf-8" ) as content_file: \n \xa0\xa0\xa0\xa0 md_content  =   content_file.read() \n # title_str, category_str, tags_str, content = get_cat_tag_content(p.b) \n title_str, category_str, tags_str, content  =   get_cat_tag_content(md_content) \n category  =   category_str.split( ":" )[ 1 ] \n tags  =   tags_str.split( ":" )[ 1 ].split( "," ) \n tags.append(category) \n # title 是一個單獨的字串 \n title  =   title_str.split( ":" )[ 1 ] \n # 將 markdown 格式 content 轉為 html \n content  =   markdown(content) \n # 以下處理 content 的 <h2> 標題 \n content  =   content.replace( "<h2>" ,  "<h2><font size=\'4\'>" ) \n content  =   content.replace( "</h2>" ,  "</font></h2>" ) \n # g.es(content) \n \xa0 \n try : \n \xa0\xa0\xa0\xa0 \'\'\' \n \xa0\xa0\xa0\xa0 users = service.users() \n \xa0\xa0\xa0\xa0 # 取得使用者 profile 資料 \n \xa0\xa0\xa0\xa0 user = users.get(userId=\'self\').execute() \n \xa0\xa0\xa0\xa0 print(\'網誌名稱: %s\' % user[\'displayName\']) \n \xa0\xa0\xa0\xa0 \'\'\' \n \xa0\xa0\xa0\xa0 blogs  =   service.blogs() \n \xa0\xa0\xa0\xa0 # 取得使用者所建立網誌名稱 \n \xa0\xa0\xa0\xa0 blogs  =   blogs.listByUser(userId = \'self\' ).execute() \n \xa0\xa0\xa0\xa0 # post_id is now blogs["items"][0]["id"] \n \xa0\xa0\xa0\xa0 blog_id  =   blogs[ "items" ][ 0 ][ "id" ] \n \xa0\xa0\xa0\xa0 #for blog in blogs[\'items\']: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 #print(blog[\'name\'], blog[\'url\']) \n \xa0\xa0\xa0\xa0 posts  =   service.posts() \n \xa0\xa0\xa0\xa0 # 新增網誌 post 時, 需要 post_id \n \xa0\xa0\xa0\xa0 body  =   { \n \xa0\xa0\xa0\xa0 "kind" :  "blogger#post" , \n \xa0\xa0\xa0\xa0 "id" : blog_id, \n \xa0\xa0\xa0\xa0 "title" : title, \n \xa0\xa0\xa0\xa0 # 利用 markdown 函式, 將 .md 的內文轉為 html, 作為 Blogger 的文章內容 \n \xa0\xa0\xa0\xa0 "content" : content, \n \xa0\xa0\xa0\xa0 "labels" : tags \n \xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0 insert  =   posts.insert(blogId = blog_id, body = body) \n \xa0\xa0\xa0\xa0 posts_doc  =   insert.execute() \n \xa0\xa0\xa0\xa0 post_id  =   posts_doc[ "id" ] \n \xa0\xa0\xa0\xa0 #print(posts_doc) \n \xa0\xa0\xa0\xa0 os.remove( "blogger.dat" ) \n \xa0\xa0\xa0\xa0 # 利用最後的 child 節點來儲存 post_id \n \xa0\xa0\xa0\xa0 to_save_post_id  =   p.insertAsLastChild()\xa0\xa0  \n \xa0\xa0\xa0\xa0 # 改為內文為空的節點, id 直接標在 head 標題  \n \xa0\xa0\xa0\xa0 to_save_post_id.b  =   "" \n \xa0\xa0\xa0\xa0 to_save_post_id.h  =   post_id \n \xa0\xa0\xa0\xa0 # 因為新增節點, commander 必須 redraw \n \xa0\xa0\xa0\xa0 c.redraw() \n \xa0\xa0\xa0\xa0 g.es( "post_id 為" , post_id) \n \xa0\xa0\xa0\xa0 g.es( "已經將資料送往 Blogger!" ) \n except (client.AccessTokenRefreshError): \n \xa0\xa0\xa0\xa0 g.es( "error" ) \n \n \n \n \n \n \n \n edit_to_blogger 按鈕內容: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n 57 \n 58 \n 59 \n 60 \n 61 \n 62 \n 63 \n 64 \n 65 \n 66 \n 67 \n 68 \n 69 \n 70 \n 71 \n 72 \n 73 \n 74 \n 75 \n 76 \n 77 \n 78 \n 79 \n 80 \n \n \n \n from   markdown  import   markdown \n from   oauth2client  import   client \n from   googleapiclient  import   sample_tools \n import   os \n \xa0 \n os.environ[ \'TZ\' ]  =   \'Asia/Taipei\' \n argv  =   "" \n # 認證並建立服務 \n # name of the api is "blogger", version is "v3" \n # description of the api is __doc__ \n # file name of the application: location of client_secrets.json \n service, flags  =   sample_tools.init( \n \xa0\xa0 argv,  \'blogger\' ,  \'v3\' , __doc__,  "./../../client_secrets.json" , \n \xa0\xa0 scope = \'https://www.googleapis.com/auth/blogger\' ) \n \xa0 \n \xa0 \n def   get_cat_tag_content(data): \n \xa0\xa0\xa0\xa0 # 請注意, 因為 data 來自 .md 的檔案 內容, 第1行為 --- \n \xa0\xa0\xa0\xa0 # 用跳行符號分割 \n \xa0\xa0\xa0\xa0 data_list  =   data.split( "\\n" ) \n \xa0\xa0\xa0\xa0 #第 2 行為 title \n \xa0\xa0\xa0\xa0 title =   data_list[ 1 ] \n \xa0\xa0\xa0\xa0 #第 4 行為 category \n \xa0\xa0\xa0\xa0 category  =   data_list[ 3 ] \n \xa0\xa0\xa0\xa0 #第 5 行為 tags \n \xa0\xa0\xa0\xa0 tags  =   data_list[ 4 ] \n \xa0\xa0\xa0\xa0 # 有多項資料的 content 型別為數列 \n \xa0\xa0\xa0\xa0 # 再將第 9 行之後的資料數列串回成以跳行隔開的資料 \n \xa0\xa0\xa0\xa0 content  =   "\\n" .join(data_list[ 8 :]) \n \xa0\xa0\xa0\xa0 # 先將截斷摘要與內文的 pelican md 檔按符號, 換成 Blogger 的 <!--more--> \n \xa0\xa0\xa0\xa0 content  =   content.replace( \'<!-- PELICAN_END_SUMMARY -->\' ,  \'<!--more-->\' ) \n \xa0\xa0\xa0\xa0 # 接著若內容有 ~~~python 與 ~~~ 則換成 Wordpress 格式 \n \xa0\xa0\xa0\xa0 #content = content.replace(\'~~~python\', \'[code lang="python"]\') \n \xa0\xa0\xa0\xa0 #content = content.replace(\'~~~\', \'[/code]\') \n \xa0\xa0\xa0\xa0 return   title, category, tags, content \n \xa0 \n # 從目前所在節點的 body pan 中取出類別, tags 以及文章內容 \n # p.h 為 @clean filename.md \n # 因為要使用 @clean 節點掛上為後的 blogger post_id, 因此改為讀 .md 檔案 \n md_filename  =   p.h.split( " " )[ 1 ] \n with  open (md_filename,  \'r\' , encoding = "utf-8" ) as content_file: \n \xa0\xa0\xa0\xa0 md_content  =   content_file.read() \n # title_str, category_str, tags_str, content = get_cat_tag_content(p.b) \n title_str, category_str, tags_str, content  =   get_cat_tag_content(md_content) \n category  =   category_str.split( ":" )[ 1 ] \n tags  =   tags_str.split( ":" )[ 1 ].split( "," ) \n tags.append(category) \n # title 是一個單獨的字串 \n title  =   title_str.split( ":" )[ 1 ] \n # 將 markdown 格式 content 轉為 html \n content  =   markdown(content) \n # 以下處理 content 的 <h2> 標題 \n content  =   content.replace( "<h2>" ,  "<h2><font size=\'4\'>" ) \n content  =   content.replace( "</h2>" ,  "</font></h2>" ) \n # g.es(content) \n \xa0 \n try : \n \xa0\xa0\xa0\xa0 blogs  =   service.blogs() \n \xa0\xa0\xa0\xa0 # 取得使用者所建立網誌名稱 \n \xa0\xa0\xa0\xa0 blogs  =   blogs.listByUser(userId = \'self\' ).execute() \n \xa0\xa0\xa0\xa0 blog_id  =   blogs[ "items" ][ 0 ][ "id" ] \n \xa0\xa0\xa0\xa0 # 設法取得原 post 的 id \n \xa0\xa0\xa0\xa0 postid_outline  =   p.getLastChild() \n \xa0\xa0\xa0\xa0 # 直接從標題取得 post 的 id 號碼 \n \xa0\xa0\xa0\xa0 post_id  =   postid_outline.h \n \xa0\xa0\xa0\xa0 posts  =   service.posts() \n \xa0\xa0\xa0\xa0 # 更新網誌文章時的 body \n \xa0\xa0\xa0\xa0 body  =   { \n \xa0\xa0\xa0\xa0 "kind" :  "blogger#post" , \n \xa0\xa0\xa0\xa0 "title" : title, \n \xa0\xa0\xa0\xa0 "content" : content \n \xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0 # need to save postId to outline head \n \xa0\xa0\xa0\xa0 update  =   posts.update(blogId = blog_id, postId = post_id, body = body, publish = True ) \n \xa0\xa0\xa0\xa0 update_doc  =   update.execute() \n \xa0\xa0\xa0\xa0 os.remove( "blogger.dat" ) \n \xa0\xa0\xa0\xa0 g.es( "post_id 為" , post_id) \n \xa0\xa0\xa0\xa0 g.es( "已經將更新資料送往 Blogger!" ) \n except (client.AccessTokenRefreshError): \n \xa0\xa0\xa0\xa0 g.es( "error" ) \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': 'W13.html'}, {'title': 'w14', 'text': '', 'tags': '', 'url': 'w14.html'}, {'title': 'MacBook 操作指南', 'text': '\n 參考資料: \n Mac OS X for Absolute Beginners.pdf \xa0 (for @gm users only) \n Learn C on the Mac.pdf \xa0 (for @gm users only) \n 這裡以 MacBook Air 2012 年出廠, 硬體規格: \n macOS Catalina Version 10.15.4 \n 1.8 GHz Dual-Core Intel Core i5 \n Memory $GB 1600 MHz DDR3 \n Graphics Intel HD Graphics 4000 1536 MB \n 的操作為例, 如何存活在機械設計工程系與精密機械工程科的網際內容管理課程. \n 由於網際內容管理課程主要以 Ｗindows 10 64 位元操作系統中的 Python 3 可攜程式環境使用為主. \n 從官方網站下載安裝 Python3 \n 因此 Catalina 系統中的首要任務, 便是安裝 Python 3: \n 在 2020.05.15 從 \xa0 https://www.python.org/downloads/mac-osx/ \xa0 可以下載安裝最新的 Python 3.8.3 解譯環境. \n 安裝 pip3 \n 有了 python 3 環境之後, 就可以從 Lanuchpad -> Other -> Terminal 開啟終端機, 並從 get-pip.py 下載用來安裝 pip3 的程式碼, 以終端機上的指令進行安裝: \n \n \n \n \n \n \n 1 \n \n \n \n sudo python3 get-pip.py \n \n \n \n \n \n \n \n 安裝 pip3 之後, 可以安裝 CMSiMDE 所需的 flask, flask_cors, lxml, bs4, markdown, pelican 以及 leo: \n \n \n \n \n \n \n 1 \n \n \n \n sudo pip3 install flask flask_cors lxml bs4 markdown pelican leo \n \n \n \n \n \n \n \n 安裝 XQuartz \n 之後, 就可以安裝 \xa0 XQuartz , 以便使用 xterm 替代 terminal. \n 接下來假如要使用 SciTE 作為文字編輯器, 建議透過 \xa0 https://www.macports.org/install.php \xa0 先根據 Catalina 操作系統版本安裝 Macports 之後, 再利用: \n \n \n \n \n \n \n 1 \n \n \n \n sudo port install scite \n \n \n \n \n \n \n \n 安裝 SciTE 文字編輯器. \n 至此, 再加上 Catalina 原有的 git 指令, 使用者已經可以在 MacBook 上執行與 Windows 10 64 位元操作系統上相同的: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n \n \n \n git clone --recurse-submodules \n \xa0 \n git add . \n \xa0 \n git commit -m  "commit message" \n \xa0 \n git push \n \xa0 \n git pull \n \xa0 \n git submodule add \n \xa0 \n git remote add \n \xa0 \n git branch \n \xa0 \n git merge \n \n \n \n \n \n \n \n 等指令, 只是在執行 python 程式時, 必須使用: \n \n \n \n \n \n \n 1 \n 2 \n 3 \n \n \n \n python3 wsgi.py \n \xa0 \n pip3 install certain_module \n \n \n \n \n \n \n \n 否則直接使用 python 執行, 將會用 Python 2.7 環境執行而產生錯誤. \n 其他建議安裝套件 \n Microsoft Remote Desktop \n Firefox \n OBS \n Visual Studio Code \n Visual Studio Code Distilled.pdf \xa0 (for @gm users only) \n Flutter (Dart) \n 其他提示 \n Command + Shift + . (toggle hidden folders and files) \n W14 << \xa0 Previous \xa0 Next \xa0 >> W15-W18 \n \n \n Copyright ©2020 All rights reserved | This template is made with \xa0 \xa0 by \xa0 Colorlib \n', 'tags': '', 'url': 'MacBook 操作指南.html'}, {'title': '直接在操作系統建立網際內容管理合用系統', 'text': '\n Windows 10 64 位元操作系統 \n 安裝 Python 3.8.3 與 pip \n 至\xa0 https://www.python.org/downloads/windows/ \xa0下載 Python 3.8.3 \xa0 Windows x86-64 executable installer \n 可以直接選擇安裝 pip 與所有選項內容 \n 安裝 Git \n 利用\xa0 64-bit Git for Windows Setup \xa0安裝 Git 工具. \n 安裝 CMSiMDE 所需模組 \n 利用 cmd 開啟命令列視窗, 以 pip 安裝 flask flask_cors lxml bs4 markdown pelican leo 等模組 \n pip install\xa0 \xa0flask flask_cors lxml bs4 markdown pelican leo \n Ubuntu 20.04 操作系統 (請下載 \xa0 W12 Virtualbox 虛擬主機檔案 ) \n Ubuntu 20.04 同時存在 Python 2.7 與 Python 3.8.2,\xa0 CMSiMDE 只相容於 Python 3.8.2, 因此啟動指令必須使用: \n python3 wsgi.py \n 與\xa0 \n pip3 install\xa0 \xa0flask flask_cors lxml bs4 markdown pelican leo \n Mac OS X 操作系統 \n 與 Ubuntu 20.04 類似. \n Blogger API << \xa0 Previous \xa0 Next \xa0 >> MacBook 操作指南 \n \n \n Copyright ©2020 All rights reserved | This template is made with \xa0 \xa0 by \xa0 Colorlib \n \n', 'tags': '', 'url': '直接在操作系統建立網際內容管理合用系統.html'}, {'title': '新增 blogger 文章', 'text': 'w14_blogger_add_1.py \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n \n \n \n \'\'\' \n 用來測試 Google Blogger Python API 新增文章程式 \n \xa0 \n pip install google-api-python-client oauth2client \n \xa0 \n \'\'\' \n \xa0 \n import   sys \n from   oauth2client  import   client \n from   googleapiclient  import   sample_tools \n \xa0 \n argv  =   "" \n # 認證並建立服務 \n service, flags  =   sample_tools.init( \n \xa0\xa0 argv,  \'blogger\' ,  \'v3\' , __doc__,  \'./client_secrets.json\' , \n \xa0\xa0 scope = \'https://www.googleapis.com/auth/blogger\' ) \n \xa0 \n try : \n \xa0\xa0\xa0\xa0 users  =   service.users() \n \xa0\xa0\xa0\xa0 # 取得使用者 profile 資料 \n \xa0\xa0\xa0\xa0 user  =   users.get(userId = \'self\' ).execute() \n \xa0\xa0\xa0\xa0 print ( \'網誌名稱: %s\'   %   user[ \'displayName\' ]) \n \xa0\xa0\xa0\xa0 blogs  =   service.blogs() \n \xa0\xa0\xa0\xa0 # 取得使用者所建立網誌名稱 \n \xa0\xa0\xa0\xa0 blogs  =   blogs.listByUser(userId = \'self\' ).execute() \n \xa0\xa0\xa0\xa0 for   blog  in   blogs[ \'items\' ]: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print (blog[ \'name\' ], blog[ \'url\' ]) \n \xa0\xa0\xa0\xa0 posts  =   service.posts() \n \xa0\xa0\xa0\xa0 # 新增網誌 post 時, 需要 blog id \n \xa0 \n \xa0\xa0\xa0\xa0 body  =   { \n \xa0\xa0\xa0\xa0 "kind" :  "blogger#post" , \n \xa0\xa0\xa0\xa0 "id" :  "123" , \n \xa0\xa0\xa0\xa0 "title" :  "透過 Python 程式新增網誌文章1" , \n \xa0\xa0\xa0\xa0 "content" : "使用 Google Blogger API 可以利用程式新增網誌文章內容1" \n \xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 insert  =   posts.insert(blogId = \'123\' , body = body) \n \xa0\xa0\xa0\xa0 posts_doc  =   insert.execute() \n \xa0\xa0\xa0\xa0 print (posts_doc) \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 \'\'\' \n \xa0\xa0\xa0\xa0 # 更新網誌文章時的 body \n \xa0\xa0\xa0\xa0 body = { \n \xa0\xa0\xa0\xa0 "kind": "blogger#post", \n \xa0\xa0\xa0\xa0 "title": "透過 Python 程式修改網誌文章2", \n \xa0\xa0\xa0\xa0 "content": "使用 Google Blogger API 可以利用程式修改網誌文章內容. http://mde.tw/cd2019" \n \xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 update = posts.update(blogId="123", postId="456", body=body, publish=True) \n \xa0\xa0\xa0\xa0 update_doc = update.execute() \n \xa0\xa0\xa0\xa0 print(update_doc) \n \xa0\xa0\xa0\xa0 \'\'\' \n except (client.AccessTokenRefreshError): \n \xa0\xa0\xa0\xa0 print ( "error" ) \n \n \n \n \n \n \n \n', 'tags': '', 'url': '新增 blogger 文章.html'}, {'title': '編輯 Blogger 文章', 'text': 'w14_blogger_edit_1.py \n \n \n \n \n \n \n 1 \n 2 \n 3 \n 4 \n 5 \n 6 \n 7 \n 8 \n 9 \n 10 \n 11 \n 12 \n 13 \n 14 \n 15 \n 16 \n 17 \n 18 \n 19 \n 20 \n 21 \n 22 \n 23 \n 24 \n 25 \n 26 \n 27 \n 28 \n 29 \n 30 \n 31 \n 32 \n 33 \n 34 \n 35 \n 36 \n 37 \n 38 \n 39 \n 40 \n 41 \n 42 \n 43 \n 44 \n 45 \n 46 \n 47 \n 48 \n 49 \n 50 \n 51 \n 52 \n 53 \n 54 \n 55 \n 56 \n \n \n \n \'\'\' \n 用來測試 Google Blogger Python API 編輯文章程式 \n \xa0 \n pip install google-api-python-client oauth2client \n \xa0 \n \'\'\' \n \xa0 \n import   sys \n from   oauth2client  import   client \n from   googleapiclient  import   sample_tools \n \xa0 \n argv  =   "" \n # 認證並建立服務 \n service, flags  =   sample_tools.init( \n \xa0\xa0 argv,  \'blogger\' ,  \'v3\' , __doc__,  \'./client_secrets.json\' , \n \xa0\xa0 scope = \'https://www.googleapis.com/auth/blogger\' ) \n \xa0 \n try : \n \xa0\xa0\xa0\xa0 users  =   service.users() \n \xa0\xa0\xa0\xa0 # 取得使用者 profile 資料 \n \xa0\xa0\xa0\xa0 user  =   users.get(userId = \'self\' ).execute() \n \xa0\xa0\xa0\xa0 print ( \'網誌名稱: %s\'   %   user[ \'displayName\' ]) \n \xa0\xa0\xa0\xa0 blogs  =   service.blogs() \n \xa0\xa0\xa0\xa0 # 取得使用者所建立網誌名稱 \n \xa0\xa0\xa0\xa0 blogs  =   blogs.listByUser(userId = \'self\' ).execute() \n \xa0\xa0\xa0\xa0 for   blog  in   blogs[ \'items\' ]: \n \xa0\xa0\xa0\xa0\xa0\xa0\xa0\xa0 print (blog[ \'name\' ], blog[ \'url\' ]) \n \xa0\xa0\xa0\xa0 posts  =   service.posts() \n \xa0\xa0\xa0\xa0 # 新增網誌 post 時, 需要 blog id \n \xa0 \n \xa0\xa0\xa0\xa0 \'\'\' \n \xa0\xa0\xa0\xa0 body = { \n \xa0\xa0\xa0\xa0 "kind": "blogger#post", \n \xa0\xa0\xa0\xa0 "id": "123", \n \xa0\xa0\xa0\xa0 "title": "透過 Python 程式新增網誌文章1", \n \xa0\xa0\xa0\xa0 "content":"使用 Google Blogger API 可以利用程式新增網誌文章內容1" \n \xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 insert = posts.insert(blogId=\'123\', body=body) \n \xa0\xa0\xa0\xa0 posts_doc = insert.execute() \n \xa0\xa0\xa0\xa0 print(posts_doc) \n \xa0\xa0\xa0\xa0 \'\'\' \n \xa0 \n \xa0\xa0\xa0\xa0 # 更新網誌文章時的 body \n \xa0\xa0\xa0\xa0 body  =   { \n \xa0\xa0\xa0\xa0 "kind" :  "blogger#post" , \n \xa0\xa0\xa0\xa0 "title" :  "透過 Python 程式修改網誌文章2" , \n \xa0\xa0\xa0\xa0 "content" :  "使用 Google Blogger API 可以利用程式修改網誌文章內容. http://mde.tw/cd2019" \n \xa0\xa0\xa0\xa0 } \n \xa0\xa0\xa0\xa0 \xa0 \n \xa0\xa0\xa0\xa0 update  =   posts.update(blogId = "123" , postId = "456" , body = body, publish = True ) \n \xa0\xa0\xa0\xa0 update_doc  =   update.execute() \n \xa0\xa0\xa0\xa0 print (update_doc) \n \xa0 \n except (client.AccessTokenRefreshError): \n \xa0\xa0\xa0\xa0 print ( "error" ) \n \n \n \n \n \n \n \n \n \n', 'tags': '', 'url': '編輯 Blogger 文章.html'}]};